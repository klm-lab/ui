"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateOutput = void 0;
const ts = require("typescript");
const package_version_1 = require("./helpers/package-version");
const typescript_1 = require("./helpers/typescript");
function generateOutput(params, options = {}) {
    let resultOutput = '';
    if (!options.noBanner) {
        resultOutput += `// Generated by dts-bundle-generator v${(0, package_version_1.packageVersion)()}\n\n`;
    }
    if (params.typesReferences.size !== 0) {
        const header = generateReferenceTypesDirective(Array.from(params.typesReferences));
        resultOutput += `${header}\n\n`;
    }
    if (params.imports.size !== 0) {
        // we need to have sorted imports of libraries to have more "stable" output
        const sortedEntries = Array.from(params.imports.entries()).sort((firstEntry, secondEntry) => {
            return firstEntry[0].localeCompare(secondEntry[0]);
        });
        const importsArray = [];
        for (const [libraryName, libraryImports] of sortedEntries) {
            importsArray.push(...generateImports(libraryName, libraryImports));
        }
        if (importsArray.length !== 0) {
            resultOutput += `${importsArray.join('\n')}\n\n`;
        }
    }
    const statements = params.statements.map((statement) => getStatementText(statement, Boolean(options.sortStatements), params));
    if (options.sortStatements) {
        statements.sort(compareStatementText);
    }
    resultOutput += statementsTextToString(statements);
    if (params.renamedExports.length !== 0) {
        resultOutput += `\n\nexport {\n\t${params.renamedExports.sort().join(',\n\t')},\n};`;
    }
    if (options.umdModuleName !== undefined) {
        resultOutput += `\n\nexport as namespace ${options.umdModuleName};`;
    }
    // this is used to prevent importing non-exported nodes
    // see https://stackoverflow.com/questions/52583603/intentional-that-export-shuts-off-automatic-export-of-all-symbols-from-a-ty
    resultOutput += `\n\nexport {};\n`;
    return resultOutput;
}
exports.generateOutput = generateOutput;
function statementsTextToString(statements) {
    const statementsText = statements.map(statement => statement.text).join('\n');
    return spacesToTabs(prettifyStatementsText(statementsText));
}
function prettifyStatementsText(statementsText) {
    const sourceFile = ts.createSourceFile('output.d.ts', statementsText, ts.ScriptTarget.Latest, false, ts.ScriptKind.TS);
    const printer = ts.createPrinter({
        newLine: ts.NewLineKind.LineFeed,
        removeComments: false,
    });
    return printer.printFile(sourceFile).trim();
}
function compareStatementText(a, b) {
    if (a.sortingValue > b.sortingValue) {
        return 1;
    }
    else if (a.sortingValue < b.sortingValue) {
        return -1;
    }
    return 0;
}
function getStatementText(statement, includeSortingValue, helpers) {
    const shouldStatementHasExportKeyword = helpers.shouldStatementHasExportKeyword(statement);
    const printer = ts.createPrinter({
        newLine: ts.NewLineKind.LineFeed,
        removeComments: false,
    }, {
        // eslint-disable-next-line complexity
        substituteNode: (hint, node) => {
            // `import('module').Qualifier` or `typeof import('module').Qualifier`
            if (ts.isImportTypeNode(node) && node.qualifier !== undefined && helpers.needStripImportFromImportTypeNode(node)) {
                if (node.isTypeOf) {
                    return ts.factory.createTypeQueryNode(node.qualifier);
                }
                return ts.factory.createTypeReferenceNode(node.qualifier, node.typeArguments);
            }
            if (node !== statement) {
                return node;
            }
            const modifiersMap = (0, typescript_1.modifiersToMap)((0, typescript_1.getModifiers)(node));
            if (ts.isEnumDeclaration(node)
                && modifiersMap[ts.SyntaxKind.ConstKeyword]
                && helpers.needStripConstFromConstEnum(node)) {
                modifiersMap[ts.SyntaxKind.ConstKeyword] = false;
            }
            let newName;
            // strip the `default` keyword from node
            if (modifiersMap[ts.SyntaxKind.DefaultKeyword]) {
                const needStripDefaultKeywordResult = helpers.needStripDefaultKeywordForStatement(statement);
                if (needStripDefaultKeywordResult.needStrip) {
                    // we need just to remove `default` from any node except class node
                    // for classes we need to replace `default` with `declare` instead
                    modifiersMap[ts.SyntaxKind.DefaultKeyword] = false;
                    if (ts.isClassDeclaration(node)) {
                        modifiersMap[ts.SyntaxKind.DeclareKeyword] = true;
                    }
                    newName = needStripDefaultKeywordResult.newName;
                }
            }
            if (!shouldStatementHasExportKeyword) {
                modifiersMap[ts.SyntaxKind.ExportKeyword] = false;
            }
            else {
                modifiersMap[ts.SyntaxKind.ExportKeyword] = true;
            }
            // for some reason TypeScript allows to not write `declare` keyword for ClassDeclaration, FunctionDeclaration and VariableDeclaration
            // if it already has `export` keyword - so we need to add it
            // to avoid TS1046: Top-level declarations in .d.ts files must start with either a 'declare' or 'export' modifier.
            if (!modifiersMap[ts.SyntaxKind.ExportKeyword] &&
                (ts.isClassDeclaration(node)
                    || ts.isFunctionDeclaration(node)
                    || ts.isVariableStatement(node)
                    || ts.isEnumDeclaration(node)
                    || ts.isModuleDeclaration(node))) {
                modifiersMap[ts.SyntaxKind.DeclareKeyword] = true;
            }
            return (0, typescript_1.recreateRootLevelNodeWithModifiers)(node, modifiersMap, newName, shouldStatementHasExportKeyword);
        },
    });
    const statementText = printer.printNode(ts.EmitHint.Unspecified, statement, statement.getSourceFile()).trim();
    let sortingValue = '';
    if (includeSortingValue) {
        // it looks like there is no way to get node's text without a comment at the same time as printing it
        // so to get the actual node text we have to parse it again
        // hopefully it shouldn't take too long (we don't need to do type check, just parse the AST)
        // also let's do it opt-in so if someone isn't using node sorting it won't affect them
        const tempSourceFile = ts.createSourceFile('temp.d.ts', statementText, ts.ScriptTarget.ESNext);
        // we certainly know that there should be 1 statement at the root level (the printed statement)
        sortingValue = tempSourceFile.getChildren()[0].getText();
    }
    return { text: statementText, sortingValue };
}
function generateImports(libraryName, imports) {
    const fromEnding = `from '${libraryName}';`;
    const result = [];
    // sort to make output more "stable"
    Array.from(imports.starImports).sort().forEach((importName) => result.push(`import * as ${importName} ${fromEnding}`));
    Array.from(imports.requireImports).sort().forEach((importName) => result.push(`import ${importName} = require('${libraryName}');`));
    Array.from(imports.defaultImports).sort().forEach((importName) => result.push(`import ${importName} ${fromEnding}`));
    if (imports.namedImports.size !== 0) {
        result.push(`import { ${Array.from(imports.namedImports).sort().join(', ')} } ${fromEnding}`);
    }
    return result;
}
function generateReferenceTypesDirective(libraries) {
    return libraries.sort().map((library) => {
        return `/// <reference types="${library}" />`;
    }).join('\n');
}
function spacesToTabs(text) {
    // eslint-disable-next-line no-regex-spaces
    return text.replace(/^(    )+/gm, (substring) => {
        return '\t'.repeat(substring.length / 4);
    });
}
